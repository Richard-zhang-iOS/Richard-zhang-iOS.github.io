<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Runtime," />










<meta name="description" content="Runtime复习整理Runtime 是一个用 C 语言和编译语言写的API，称为“运行时”，它的应用使 Objective-C 拥有相当多的动态特性。具体怎么实现的呢。我们从下面几个方面探寻 Runtime 的实现机制。  Runtime 介绍 Runtime 交互方式 Runtime 常用术语的数据结构 Runtime 消息传递 Runtime 消息转发 Runtime 应用">
<meta name="keywords" content="Runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS Runtime 复习整理">
<meta property="og:url" content="https://github.com/Richard-zhang-iOS/Richard-zhang-iOS.github.io/2018/07/27/runtime机制/index.html">
<meta property="og:site_name" content="Richard-zhang-iOS的博客">
<meta property="og:description" content="Runtime复习整理Runtime 是一个用 C 语言和编译语言写的API，称为“运行时”，它的应用使 Objective-C 拥有相当多的动态特性。具体怎么实现的呢。我们从下面几个方面探寻 Runtime 的实现机制。  Runtime 介绍 Runtime 交互方式 Runtime 常用术语的数据结构 Runtime 消息传递 Runtime 消息转发 Runtime 应用">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/301129-cc9c0a7ffb147fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1330553-87d03a7c0971c730.gif?imageMogr2/auto-orient/strip">
<meta property="og:updated_time" content="2018-08-18T07:07:36.035Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS Runtime 复习整理">
<meta name="twitter:description" content="Runtime复习整理Runtime 是一个用 C 语言和编译语言写的API，称为“运行时”，它的应用使 Objective-C 拥有相当多的动态特性。具体怎么实现的呢。我们从下面几个方面探寻 Runtime 的实现机制。  Runtime 介绍 Runtime 交互方式 Runtime 常用术语的数据结构 Runtime 消息传递 Runtime 消息转发 Runtime 应用">
<meta name="twitter:image" content="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/Richard-zhang-iOS/Richard-zhang-iOS.github.io/2018/07/27/runtime机制/"/>





  <title>iOS Runtime 复习整理 | Richard-zhang-iOS的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Richard-zhang-iOS的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/Richard-zhang-iOS/Richard-zhang-iOS.github.io/2018/07/27/runtime机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Richard-zhang-iOS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richard-zhang-iOS的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS Runtime 复习整理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T22:47:44+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Runtime复习整理"><a href="#Runtime复习整理" class="headerlink" title="Runtime复习整理"></a>Runtime复习整理</h1><p>Runtime 是一个用 C 语言和编译语言写的API，称为“运行时”，它的应用使 Objective-C 拥有相当多的动态特性。具体怎么实现的呢。我们从下面几个方面探寻 Runtime 的实现机制。</p>
<ul>
<li>Runtime 介绍</li>
<li>Runtime 交互方式</li>
<li>Runtime 常用术语的数据结构</li>
<li>Runtime 消息传递</li>
<li>Runtime 消息转发</li>
<li>Runtime 应用</li>
</ul>
<a id="more"></a>
<h2 id="Runtime介绍"><a href="#Runtime介绍" class="headerlink" title="Runtime介绍"></a>Runtime介绍</h2><p>本章节包括：</p>
<ul>
<li>Runtime概述</li>
<li>代码到可执行文件过程</li>
<li>源码地址</li>
<li>版本和平台</li>
</ul>
<h3 id="Runtime概述"><a href="#Runtime概述" class="headerlink" title="Runtime概述"></a>Runtime概述</h3><blockquote>
<p>Objective-C 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。</p>
</blockquote>
<blockquote>
<p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石。</p>
</blockquote>
<p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是<code>OC</code>并不能直接编译为汇编语言，而是要先转写为纯<code>C</code>语言再进行编译和汇编的操作，从<code>OC</code>到<code>C</code>语言的过渡就是由 runtime 来实现的。在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。</p>
<p>对于 C 语言，函数的调用会在编译期就已经决定好，在编译完成后直接顺序执行。但是 OC 是一门动态语言，函数调用变成了消息发送，在编译期不能知道要调用哪个函数。所以 Runtime 无非就是去解决如何在运行时期来动态得创建类和对象、进行消息传递和转发。</p>
<p>理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。</p>
<h3 id="代码到可执行文件过程"><a href="#代码到可执行文件过程" class="headerlink" title="代码到可执行文件过程"></a>代码到可执行文件过程</h3><p>这是《深入理解计算机系统(第2版)》里面的一张截图：</p>
<p><a href="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png" target="_blank" rel="noopener"><img src="http://on0hv7n2x.bkt.clouddn.com/compileToLinkToRun.png" alt="img"></a></p>
<p>主要过程我们可以简化成三个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译</span><br><span class="line">- 链接</span><br><span class="line">- 运行</span><br></pre></td></tr></table></figure>
<p>编译：将代码转换成底层可执行的语言（如汇编），简单来讲，就是把你能看懂的语言，转换成系统底层可以看懂的东西，这中间通常会有优化，先预处理，再编译。</p>
<p>链接：在编译的过程中，如果有调用其他的类的方法等，是不会检查或者报警的，编译的时候会默认你已经实现了。而链接就是去检查调用的方法或者类等是否确实存在。</p>
<p>运行：执行最终的可执行文件</p>
<p>如果是普通的C语言代码，我们使用的是传统的编译运行，那么一个函数的执行内容，在编译阶段其实就确定了，执行的时候只要去执行对应的内存地址的程序就好。</p>
<p>而在<code>runtime</code>中，编译阶段只能确定最终要执行的函数名，但是具体执行的时候，执行的是什么程序，是在运行的时候才能确定，大大增加了程序的灵活性。</p>
<h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p><code>Runtime</code> 基本是用 <code>C</code> 和<code>汇编</code>写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.opensource.apple.com%2Fsource%2Fobjc4%2F" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码。在这里先放上runtime的源码和runtime官方api:</p>
<ul>
<li>源码：<a href="https://github.com/RetVal/objc-runtime">objc-runtime</a></li>
<li>官方API：<a href="https://developer.apple.com/reference/objectivec/objective_c_runtime#//apple_ref/doc/uid/TP40001418-CH1g-126286" target="_blank" rel="noopener">Objective-C Runtime Reference</a></li>
</ul>
<h3 id="版本和平台"><a href="#版本和平台" class="headerlink" title="版本和平台"></a>版本和平台</h3><p>Runtime是有个两个版本的: legacy 、 modern<br>在Objective-C 1.0使用的是legacy，在2.0使用的是modern。这里简单介绍下区别：</p>
<ul>
<li>在legacy runtime，如果你改变了实例变量的设计，需要重新编译它的子类。支持 32bit的OS X 程序</li>
<li>在modern runtime，如果你改变了实例变量的设计，不需要重新编译它的子类。支持iphone程序和OS X10.5之后的64bit程序</li>
</ul>
<p>因为legacy是如此的古老，我们基本可以忽略legacy版本。</p>
<h2 id="Runtime-的交互"><a href="#Runtime-的交互" class="headerlink" title="Runtime 的交互"></a>Runtime 的交互</h2><p>Objc 在三种层面上与 Runtime 系统进行交互：</p>
<ul>
<li>Objective-C 源代码</li>
<li>NSObject </li>
<li>Runtime 库</li>
</ul>
<h3 id="Objective-C-源代码"><a href="#Objective-C-源代码" class="headerlink" title="Objective-C 源代码"></a>Objective-C 源代码</h3><p>多数情况我们只需要编写 OC 代码即可，Runtime 系统自动在幕后搞定一切，编译器会将 OC 代码转换成运行时代码，在运行时确定数据结构和函数。</p>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><p>Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(NSProxy 类时个例外，它是个抽象超类)</p>
<p>一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 <code>-description</code> 方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject 的子类可以重新实现。</p>
<p>还有一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如：</p>
<ul>
<li><code>-class</code>方法返回对象的类；</li>
<li><code>-isKindOfClass:</code> 和 <code>-isMemberOfClass:</code> 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；</li>
<li><code>-respondsToSelector:</code> 检查对象能否响应指定的消息；</li>
<li><code>-conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；</li>
<li><code>-methodForSelector:</code> 返回指定方法实现的地址。</li>
</ul>
<h3 id="Runtime-库"><a href="#Runtime-库" class="headerlink" title="Runtime 库"></a>Runtime 库</h3><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下，这意味着我们使用时只需要引入<code>objc/Runtime.h</code>头文件即可。</p>
<p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则你一般不会直接用到这些函数的，在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>
<h2 id="Runtime-常用术语的数据结构"><a href="#Runtime-常用术语的数据结构" class="headerlink" title="Runtime 常用术语的数据结构"></a>Runtime 常用术语的数据结构</h2><p>下面讲讲Runtime用到的一些概念：</p>
<ul>
<li>类对象(objc_class)</li>
<li>实例(objc_object)</li>
<li>元类(Meta Class)</li>
<li>Ivar（objc_ivar）</li>
<li>Method(objc_method)</li>
<li>SEL(objc_selector)</li>
<li>IMP</li>
<li>类缓存(objc_cache)</li>
<li>Property（objc_property_t）</li>
<li>Category(objc_category)</li>
</ul>
<h3 id="类对象-objc-class"><a href="#类对象-objc-class" class="headerlink" title="类对象(objc_class)"></a>类对象(objc_class)</h3><p><code>Objective-C</code>类是由<code>Class</code>类型来表示的，它实际上是一个指向<code>objc_class</code>结构体的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>查看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125;OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><code>struct objc_class</code>结构体定义了很多变量，通过命名不难发现，<br>结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，这些数据称为元数据(<code>metadata</code>)，该结构体的第一个成员变量也是<code>isa</code>指针，这就说明了<code>Class</code>本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。</p>
<h3 id="实例-objc-object"><a href="#实例-objc-object" class="headerlink" title="实例(objc_object)"></a>实例(objc_object)</h3><p>objc_object是表示一个类的实例的结构体它的定义如下(objc/objc.h)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。</p>
<h3 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h3><p>类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？</p>
<p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的<code>isa</code>指针必须指向一个包含这些类方法的一个<code>objc_class</code>结构体。这就引出了<code>meta-class</code>的概念为了调用类方法，meta-class中存储着一个类的所有类方法.所以，调用类方法的这个类对象的isa指针指向的就是meta-class。</p>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。</p>
<p>即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/301129-cc9c0a7ffb147fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"></p>
<p>通过上图我们可以看出整个体系构成了一个自闭环，</p>
<p>实例对象（objc_object） 的<code>isa</code>指针指向类对象（objc_class），类对象的<code>isa</code>指针指向了元类（Meta Class），元类的<code>isa</code>指针指向基类（NSObject）的元类，基类（NSObject）的元类指向它自己。</p>
<p>类对象（objc_class）的<code>super_class</code>指针指向了父类的类对象</p>
<p>元类（Meta Class））的<code>super_class</code>指针指向了父类的元类</p>
<h3 id="Ivar（objc-ivar）"><a href="#Ivar（objc-ivar）" class="headerlink" title="Ivar（objc_ivar）"></a>Ivar（objc_ivar）</h3><p><code>Ivar</code> 是表示成员变量的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>ivar_offset</code> 是基地址偏移字节</p>
<h3 id="Method（objc-method）"><a href="#Method（objc-method）" class="headerlink" title="Method（objc_method）"></a>Method（objc_method）</h3><p>Method 代表类中某个方法的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name          OBJC2_UNAVAILABLE;//方法名</span><br><span class="line">    char *method_types       OBJC2_UNAVAILABLE;//char 指针，存储方法的参数类型和返回值类型</span><br><span class="line">    IMP method_imp           OBJC2_UNAVAILABLE;//方法的实现，本质是一个函数指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个结构体重，我们已经看到了<code>SEL</code>和<code>IMP</code>，说明<code>SEL</code>和<code>IMP</code>其实都是<code>Method</code>的属性。</p>
<h3 id="SEL-objc-selector"><a href="#SEL-objc-selector" class="headerlink" title="SEL(objc_selector)"></a>SEL(objc_selector)</h3><p>先看下定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@include &quot;Objc.h&quot;</span><br><span class="line">/// An opaque type that represents a method selector.代表一个方法的不透明类型</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>首先区分下<code>selector</code>和<code>SEL</code>的的关系，我们先看下selector的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property SEL selector;</span><br></pre></td></tr></table></figure>
<p>可以看到SEL 是一种数据结构，<code>selector</code>是它的实例。</p>
<p><code>selector</code>是方法选择器，可以理解为区分方法的 <code>ID</code>，可以让我们能够快速找到对应的函数。而这个 <code>ID</code> 的数据结构是<code>SEL</code>。</p>
<p>在iOS中，<code>runtime</code>会在运行的时候，通过<code>load</code>函数，将所有的<code>method</code>hash然后map到<code>set</code>中。这样在运行的时候，寻找<code>selector</code>的速度就会非常快，不会因为<code>runtime</code>特性牺牲太多的性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.</span><br></pre></td></tr></table></figure>
<p><code>selector</code>既然是一个<code>string</code>，我觉得应该是类似<code>className+method</code>的组合，命名规则有两条：</p>
<ul>
<li>同一个类，selector不能重复</li>
<li>不同的类，selector可以重复</li>
</ul>
<p>这也带来了一个弊端，我们在写<code>C</code>代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在<code>Objective-C</code>中是行不通的，因为<code>selector</code>只记了<code>method</code>的<code>name</code>，没有参数，所以没法区分不同的<code>method</code>。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)caculate(NSInteger)num;</span><br><span class="line">- (void)caculate(CGFloat)num;</span><br></pre></td></tr></table></figure>
<p>是会报错的。</p>
<p>我们只能通过命名来区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)caculateWithInt(NSInteger)num;</span><br><span class="line">- (void)caculateWithFloat(CGFloat)num;</span><br></pre></td></tr></table></figure>
<p>在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>看下<code>IMP</code>的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation.  指向一个方法实现的指针</span><br><span class="line">typedef id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure>
<p>就是指向最终实现程序的内存地址的指针。</p>
<p>在<code>iOS</code>的<code>Runtime</code>中，<code>Method</code>通过<code>selector</code>和<code>IMP</code>两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。</p>
<h3 id="Cache（objc-cache）"><a href="#Cache（objc-cache）" class="headerlink" title="Cache（objc_cache）"></a>Cache（objc_cache）</h3><p>Cache 定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_cache *Cache</span><br><span class="line"></span><br><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<h3 id="Property（objc-property-t）"><a href="#Property（objc-property-t）" class="headerlink" title="Property（objc_property_t）"></a>Property（objc_property_t）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_property *Property;</span><br><span class="line">typedef struct objc_property *objc_property_t;//这个更常用</span><br></pre></td></tr></table></figure>
<p>可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code> 方法获取类和协议中的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</span><br></pre></td></tr></table></figure>
<h3 id="Category-objc-category"><a href="#Category-objc-category" class="headerlink" title="Category(objc_category)"></a>Category(objc_category)</h3><p><code>Category</code>是表示一个指向分类的结构体的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123; </span><br><span class="line">    const char *name; </span><br><span class="line">    classref_t cls; </span><br><span class="line">    struct method_list_t *instanceMethods; </span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name：是指 class_name 而不是 category_name。</span><br><span class="line">cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对 应到对应的类对象。</span><br><span class="line">instanceMethods：category中所有给类添加的实例方法的列表。</span><br><span class="line">classMethods：category中所有添加的类方法的列表。</span><br><span class="line">protocols：category实现的所有协议的列表。</span><br><span class="line">instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。</span><br></pre></td></tr></table></figure>
<p>从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</p>
<h2 id="Runtime-消息传递（dispatch-table）"><a href="#Runtime-消息传递（dispatch-table）" class="headerlink" title="Runtime 消息传递（dispatch table）"></a>Runtime 消息传递（dispatch table）</h2><p>本章节分为以下三个部分：</p>
<ul>
<li>消息传递介绍</li>
<li>消息传递流程</li>
<li>方法中的隐藏参数</li>
</ul>
<h3 id="消息传递介绍"><a href="#消息传递介绍" class="headerlink" title="消息传递介绍"></a>消息传递介绍</h3><p>基础 Runtime 术语讲完了，接下来就要说到消息了。体会苹果官方文档中的: </p>
<blockquote>
<p>messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。</p>
</blockquote>
<p>当你写下面这样的代码时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tableView cellForRowAtIndexPath:indexPath];</span><br></pre></td></tr></table></figure>
<p>编译器实际上把它转换成下面这样的C函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(tableView, @selector(cellForRowAtIndexPath:), indexPath);</span><br></pre></td></tr></table></figure>
<p>先看看苹果官方关于消息发送方法的说明：</p>
<blockquote>
<p>When it encounters a method invocation, the compiler might generate a call to any of several functions to perform the actual message dispatch, depending on the receiver, the return value, and the arguments. You can use these functions to dynamically invoke methods from your own plain C code, or to use argument forms not permitted by NSObject’s <code>perform...</code>methods. These functions are declared in <code>/usr/include/objc/objc-runtime.h</code>.</p>
<ul>
<li><a href="https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend?language=objc" target="_blank" rel="noopener"><code>objc_msgSend</code></a> sends a message with a simple return value to an instance of a class.</li>
<li><a href="https://developer.apple.com/documentation/objectivec/1456730-objc_msgsend_stret?language=objc" target="_blank" rel="noopener"><code>objc_msgSend_stret</code></a> sends a message with a data-structure return value to an instance of a class.</li>
<li><a href="https://developer.apple.com/documentation/objectivec/1456716-objc_msgsendsuper?language=objc" target="_blank" rel="noopener"><code>objc_msgSendSuper</code></a> sends a message with a simple return value to the superclass of an instance of a class.</li>
<li><a href="https://developer.apple.com/documentation/objectivec/1456722-objc_msgsendsuper_stret?language=objc" target="_blank" rel="noopener"><code>objc_msgSendSuper_stret</code></a> sends a message with a data-structure return value to the superclass of an instance of a class.</li>
</ul>
</blockquote>
<p>解释下上面的意思：</p>
<blockquote>
<p>当遇到方法调用时，编译器可能会生成以下几个函数的调用，以执行实际的消息调度，具体取决于接收者，返回值和参数。  这些函数在/usr/include/objc/objc-runtime.h中声明。具体生成规则如下：</p>
<p>objc_msgSend                         //将具有简单返回值的消息发送到类的实例。</p>
<p>objc_msgSend_stret               //将具有数据结构返回值的消息发送到类的实例。</p>
<p>objc_msgSendSuper              //将具有简单返回值的消息发送到类的实例的超类。</p>
<p>objc_msgSendSuper_stret    // 将具有数据结构返回值的消息发送到类实例的超类。</p>
</blockquote>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIView *view = [[UIView alloc] initWithFrame:CGRectZero];</span><br><span class="line">CGRect rect =  [view frame];</span><br></pre></td></tr></table></figure>
<p>由于返回值是结构体类型，编译器不会把它转换成 msgSend, 而是调用 objc_msgSend_stret，stret就是 struct return的缩写</p>
<h3 id="消息传递流程"><a href="#消息传递流程" class="headerlink" title="消息传递流程"></a>消息传递流程</h3><p>下面我们以objc_msgSend为例，详细叙述消息发送的步骤(如下图)：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1330553-87d03a7c0971c730.gif?imageMogr2/auto-orient/strip" alt="img"></p>
<ol>
<li>首先检测这个 <code>selector</code> 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。</li>
<li>检测这个 <code>selector</code> 的 target 是不是 <code>nil</code>，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</li>
<li>如果上面两步都通过了，那么就开始查找这个类的实现 <code>IMP</code>，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。</li>
<li>如果 cache 找不到就找类的方法列表中是否有对应的方法。</li>
<li>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。</li>
<li>如果还找不到，就要开始进入<strong>动态方法解析</strong>了，后面会提到。</li>
</ol>
<h3 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h3><blockquote>
<p>疑问：<br>我们经常用到关键字 <code>self</code> ，但是 <code>self</code> 是如何获取当前方法的对象呢？</p>
</blockquote>
<p>其实，这也是 Runtime 系统的作用，<code>self</code> 实在方法运行时被动态传入的。</p>
<p>当 <code>objc_msgSend</code> 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<ul>
<li>接受消息的对象(<code>self</code> 所指向的内容，当前方法的对象指针)</li>
<li>方法选择器(<code>_cmd</code> 指向的内容，当前方法的 SEL 指针)</li>
</ul>
<p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中， <code>self</code>更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<h2 id="Runtime-消息转发（Message-Forwarding）"><a href="#Runtime-消息转发（Message-Forwarding）" class="headerlink" title="Runtime 消息转发（Message Forwarding）"></a>Runtime 消息转发（Message Forwarding）</h2><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([self respondsToSelector:@selector(method)])&#123;</span><br><span class="line">      [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，我们这边想讨论下不使用respondsToSelector:判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓“消息转发(message forwarding)”机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ul>
<li>动态方法解析 - resolveInstanceMethod/resolveClassMethod</li>
<li>重定向 - forwardingTargetForSelector</li>
<li>转发 - forwardInvocation</li>
</ul>
<h3 id="动态方法解析-resolveInstanceMethod"><a href="#动态方法解析-resolveInstanceMethod" class="headerlink" title="动态方法解析 - resolveInstanceMethod"></a>动态方法解析 - resolveInstanceMethod</h3><p>对象在接收到未知的消息时，首先会调用所属类的类方法<br>+resolveInstanceMethod:(实例方法)或者<br>+resolveClassMethod:(类方法)。</p>
<p>在这个方法中，我们有机会为该未知消息新增一个“处理方法”，通过运行时class_addMethod函数动态添加到类里面就可以了。这种方案更多的是为了实现@dynamic属性。</p>
<p>举例：如果我们执行ClassA并不存在的foo方法，如果我们什么都不处理在运行时程序会崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassA *a = [ClassA new];</span><br><span class="line">[a performSelector:@selector(foo)];</span><br></pre></td></tr></table></figure>
<p>如果想要用  <code>resolveInstanceMethod</code>来补救 ，该怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;objc/runtime.h&gt;</span><br><span class="line">void foo(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;resolveInstanceMethod add method foo &quot;);</span><br><span class="line">&#125;</span><br><span class="line">@implementation ClassA</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(foo)) &#123;</span><br><span class="line">       class_addMethod([self class], sel, (IMP)foo, &quot;v@:&quot;);</span><br><span class="line">       return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的return YES 或者 return NO,是告诉系统是否实现了这个方法，如果return YES，但是并没有增加方法，还是会报错，并且不会走到forward，因为系统默认你已经在这一步做了resolveInstanceMethod这个事情。</p>
<h3 id="重定向-forwardingTargetForSelector"><a href="#重定向-forwardingTargetForSelector" class="headerlink" title="重定向 - forwardingTargetForSelector"></a>重定向 - forwardingTargetForSelector</h3><p>如果上一步骤的<code>resolveInstanceMethod</code> return no，系统会走<code>forwardingTargetForSelector</code>，这一步被称为快速转发，是因为相对下面要介绍的normal fastward，这一步直接转发了消息，而normal fastward生成了NSInvocation，相对直接转发慢一些。</p>
<p>先看下如何实现，比如，我想把消息转发给有能力的classB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassB : NSObject</span><br><span class="line">- (void)foo;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line">- (void)foo&#123;</span><br><span class="line">    NSLog(@&quot;ClassB foo run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>A中需要实现<code>forwardingTargetForSelector</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if(aSelector == @selector(foo))&#123;</span><br><span class="line">        ClassB *b = [ClassB new];</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转发-forwardInvocation"><a href="#转发-forwardInvocation" class="headerlink" title="转发 - forwardInvocation"></a>转发 - forwardInvocation</h3><p>如果你的类没有实现<code>forwardingTargetForSelector</code>方法，系统会调用<code>methodSignatureForSelector</code>方法，如果这个方法返回一个函数的签名，则执行<code>forwardInvocation</code>方法，否则执行<code>doesNotRecognizeSelector</code>。</p>
<p>如果希望在这一步补救，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    return [ClassB instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line">    ClassB *b = [ClassB new];</span><br><span class="line"></span><br><span class="line">    if([b respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:b];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>苹果的文档里，讲述了这一个消息转发的出发点，其实是为了实现类似C多继承的功能。我们知道，在C中如果一个类想要具有多个类的功能，是可以直接继承多个类的。而Objective-C是单继承，如果想实现类似的功能，就用消息转发，将消息转发给有能力处理的类。苹果是这样描述他们的思想的：C的多继承，是加法，在多继承的同时，其实也增加了很多不需要的功能，而苹果通过消息转发，实现了减法的思想，只留有用的方法，而不去增加过多内容。</p>
<h2 id="Runtime应用"><a href="#Runtime应用" class="headerlink" title="Runtime应用"></a>Runtime应用</h2><p><code>Runtime</code>简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。</p>
<ul>
<li>遍历结构体中数据（Ivar、objc_property_t、Method、Protocol）<ul>
<li>获取对应列表</li>
<li>NSCoding的自动归档/解档</li>
<li>模型/字典互转</li>
</ul>
</li>
<li>动态添加属性</li>
<li>动态添加方法与方法转发</li>
<li>黑魔法(Method Swizzling)</li>
<li>KVO实现</li>
</ul>
<h3 id="遍历结构体中数据"><a href="#遍历结构体中数据" class="headerlink" title="遍历结构体中数据"></a>遍历结构体中数据</h3><h4 id="获取对应列表"><a href="#获取对应列表" class="headerlink" title="获取对应列表"></a>获取对应列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1、获取成员变量</span><br><span class="line">  Ivar *ivarList = class_copyIvarList([self class], &amp;count);</span><br><span class="line">   for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">       Ivar myIvar = ivarList[i];</span><br><span class="line">       const char *ivarName = ivar_getName(myIvar);</span><br><span class="line">       NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</span><br><span class="line">   &#125;</span><br><span class="line">  class_copyIvarList</span><br><span class="line">  ivar_getName</span><br><span class="line">2、获取属性</span><br><span class="line">  unsigned int count;</span><br><span class="line">     //获取类的属性列表</span><br><span class="line">     objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</span><br><span class="line">     for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">         const char *propertyName = property_getName(propertyList[i]);</span><br><span class="line">         NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</span><br><span class="line">     &#125;</span><br><span class="line">    class_copyPropertyList</span><br><span class="line">    property_getName</span><br><span class="line">3、方法</span><br><span class="line"> Method *methodList = class_copyMethodList([self class], &amp;count);</span><br><span class="line">   for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">       Method method = methodList[i];</span><br><span class="line">       NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br><span class="line">   &#125;</span><br><span class="line">  class_copyMethodList</span><br><span class="line">  method_getName</span><br><span class="line">4、协议</span><br><span class="line"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</span><br><span class="line">   for (unsigned int i=0; i&lt;count; i++) &#123;</span><br><span class="line">       Protocol *myProtocal = protocolList[i];</span><br><span class="line">       const char *protocolName = protocol_getName(myProtocal);</span><br><span class="line">       NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</span><br><span class="line">   &#125;</span><br><span class="line">  class_copyProtocolList</span><br><span class="line">  protocol_getName</span><br></pre></td></tr></table></figure>
<h4 id="NSCoding的自动归档-解档"><a href="#NSCoding的自动归档-解档" class="headerlink" title="NSCoding的自动归档/解档"></a>NSCoding的自动归档/解档</h4><p>原理描述：用<code>runtime</code>提供的函数遍历<code>Model</code>自身所有属性，并对属性进行<code>encode</code>和<code>decode</code>操作。<br>核心方法：在<code>Model</code>的基类中重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">        for (int i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">            [self setValue:[aDecoder decodeObjectForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">    unsigned int outCount;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;outCount);</span><br><span class="line">    for (int i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模型-字典互转-MJExtension"><a href="#模型-字典互转-MJExtension" class="headerlink" title="模型/字典互转(MJExtension)"></a>模型/字典互转(MJExtension)</h4><p>原理描述：用<code>runtime</code>提供的函数遍历<code>Model</code>自身所有属性，如果属性在<code>json</code>中有对应的值，则将其赋值。<br>核心方法：在<code>NSObject</code>的分类中添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithDict:(NSDictionary *)dict &#123;</span><br><span class="line"></span><br><span class="line">    if (self = [self init]) &#123;</span><br><span class="line">        //(1)获取类的属性及属性对应的类型</span><br><span class="line">        NSMutableArray * keys = [NSMutableArray array];</span><br><span class="line">        NSMutableArray * attributes = [NSMutableArray array];</span><br><span class="line">        /*</span><br><span class="line">         * 例子</span><br><span class="line">         * name = value3 attribute = T@&quot;NSString&quot;,C,N,V_value3</span><br><span class="line">         * name = value4 attribute = T^i,N,V_value4</span><br><span class="line">         */</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount);</span><br><span class="line">        for (int i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            //通过property_getName函数获得属性的名字</span><br><span class="line">            NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [keys addObject:propertyName];</span><br><span class="line">            //通过property_getAttributes函数可以获得属性的名字和@encode编码</span><br><span class="line">            NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [attributes addObject:propertyAttribute];</span><br><span class="line">        &#125;</span><br><span class="line">        //立即释放properties指向的内存</span><br><span class="line">        free(properties);</span><br><span class="line"></span><br><span class="line">        //(2)根据类型给属性赋值</span><br><span class="line">        for (NSString * key in keys) &#123;</span><br><span class="line">            if ([dict valueForKey:key] == nil) continue;</span><br><span class="line">            [self setValue:[dict valueForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a><strong>动态添加属性</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//.h文件</span><br><span class="line">#import &quot;NSObject.h&quot;</span><br><span class="line">@interface NSObject (Property)</span><br><span class="line">//@property在分类中只会生成set、get方法的声明 不会生成实现，也不会生成_成员属性</span><br><span class="line">@property (nonatomic,copy)NSString name;</span><br><span class="line">@end</span><br><span class="line">-----------------------------------------------</span><br><span class="line">//.m文件</span><br><span class="line">// 定义关联的key</span><br><span class="line">static const char *key = &quot;name&quot;;</span><br><span class="line">@implementation NSObject (Property)</span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    // 根据关联的key，获取关联的值。</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     第一个参数：给哪个对象添加关联</span><br><span class="line">     第二个参数：关联的key，通过这个key获取</span><br><span class="line">     第三个参数：关联的value</span><br><span class="line">     第四个参数:关联的策略</span><br><span class="line">   */</span><br><span class="line">    objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="动态添加方法与方法转发"><a href="#动态添加方法与方法转发" class="headerlink" title="动态添加方法与方法转发"></a>动态添加方法与方法转发</h3><p>关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。同学们可以自行前往前面章节查看案例。JSPatch 是它成功使用的案例</p>
<blockquote>
<p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fbang590%2FJSPatch%2Fwiki%2FJSPatch-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%25E8%25AF%25A6%25E8%25A7%25A3" target="_blank" rel="noopener">JSPatch</a> 是一个 iOS 动态更新框架，不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。</p>
</blockquote>
<h3 id="黑魔法-Method-Swizzling"><a href="#黑魔法-Method-Swizzling" class="headerlink" title="黑魔法(Method Swizzling)"></a>黑魔法(Method Swizzling)</h3><p>下面实现一个替换<code>ViewController</code>的<code>viewDidLoad</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        SEL originalSelector = @selector(viewDidLoad);</span><br><span class="line">        SEL swizzledSelector = @selector(jkviewDidLoad);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class,originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        //judge the method named  swizzledMethod is already existed.</span><br><span class="line">        BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        // if swizzledMethod is already existed.</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jkviewDidLoad &#123;</span><br><span class="line">    NSLog(@&quot;替换的方法&quot;);</span><br><span class="line">    [self jkviewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    NSLog(@&quot;自带的方法&quot;);</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>swizzling</code>应该只在<code>+load</code>中完成。 在 <code>Objective-C</code> 的运行时中，每个类有两个方法都会自动调用。<code>+load</code> 是在一个类被初始装载时调用，<code>+initialize</code> 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p>
<p><code>swizzling</code>应该只在<code>dispatch_once</code> 中完成,由于<code>swizzling</code> 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。<code>Grand Central Dispatch 的 dispatch_once</code>满足了所需要的需求，并且应该被当做使用<code>swizzling</code> 的初始化单例方法的标准。</p>
<h3 id="KVO实现"><a href="#KVO实现" class="headerlink" title="KVO实现"></a>KVO实现</h3><blockquote>
<p>全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。</p>
</blockquote>
<p><code>KVO</code>的实现依赖于 <code>Objective-C</code> 强大的 <code>Runtime</code>，当观察某对象 <code>A</code> 时，<code>KVO</code> 机制动态创建一个对象<code>A</code>当前类的子类，并为这个新的子类重写了被观察属性 <code>keyPath</code> 的 <code>setter</code> 方法。<code>setter</code> 方法随后负责通知观察对象属性的改变状况。</p>
<p><code>Apple</code> 使用了 <code>isa-swizzling</code> 来实现 <code>KVO</code> 。当观察对象<code>A</code>时，<code>KVO</code>机制动态创建一个新的名为：<code>NSKVONotifying_A</code>的新类，该类继承自对象A的本类，且 <code>KVO</code> 为 <code>NSKVONotifying_A</code> 重写观察属性的 <code>setter</code> 方法，<code>setter</code> 方法会负责在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象属性值的更改情况。</p>
<ul>
<li>NSKVONotifying_A 类剖析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;self-&gt;isa:%@&quot;,self-&gt;isa);  </span><br><span class="line">NSLog(@&quot;self class:%@&quot;,[self class]);</span><br></pre></td></tr></table></figure>
<p>在建立KVO监听前，打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self-&gt;isa:A</span><br><span class="line">self class:A</span><br></pre></td></tr></table></figure>
<p>在建立KVO监听之后，打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self-&gt;isa:NSKVONotifying_A</span><br><span class="line">self class:A</span><br></pre></td></tr></table></figure>
<p>在这个过程，被观察对象的 <code>isa</code> 指针从指向原来的 <code>A</code> 类，被<code>KVO</code> 机制修改为指向系统新创建的子类<code>NSKVONotifying_A</code> 类，来实现当前类属性值改变的监听；<br>所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 <code>KVO</code> 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“<code>NSKVONotifying_A</code>”的类，就会发现系统运行到注册 <code>KVO</code> 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 <code>NSKVONotifying_A</code> 的中间类，并指向这个中间类了。</p>
<ul>
<li>子类setter方法剖析</li>
</ul>
<p><code>KVO</code> 的键值观察通知依赖于 NSObject 的两个方法:<code>willChangeValueForKey:</code>和 <code>didChangeValueForKey:</code> ，在存取数值的前后分别调用 2 个方法：<br>被观察属性发生改变之前，<code>willChangeValueForKey:</code>被调用，通知系统该 <code>keyPath</code> 的属性值即将变更；<br>当改变发生后， <code>didChangeValueForKey:</code> 被调用，通知系统该<code>keyPath</code> 的属性值已经变更；之后， <code>observeValueForKey:ofObject:change:context:</code>也会被调用。且重写观察属性的<code>setter</code> 方法这种继承方式的注入是在运行时而不是编译时实现的。</p>
<p><code>KVO</code> 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)newName &#123; </span><br><span class="line">      [self willChangeValueForKey:@&quot;name&quot;];    //KVO 在调用存取方法之前总调用 </span><br><span class="line">      [super setValue:newName forKey:@&quot;name&quot;]; //调用父类的存取方法 </span><br><span class="line">      [self didChangeValueForKey:@&quot;name&quot;];     //KVO 在调用存取方法之后总调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们之所以让自己的类继承<code>NSObject</code>不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。可能我们平时写代码时可能很少会考虑一句简单的<code>[receiver message]</code>背后发生了什么，而只是当做方法或函数调用。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 Method Swizzling 等。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Runtime/" rel="tag"># Runtime</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/02/JavaScriptCore/" rel="next" title="JavaScriptCore C 语言接口详解">
                <i class="fa fa-chevron-left"></i> JavaScriptCore C 语言接口详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/15/JavaScript原型/" rel="prev" title="Javascript原型总结">
                Javascript原型总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Richard-zhang-iOS" />
            
              <p class="site-author-name" itemprop="name">Richard-zhang-iOS</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Richard-zhang-iOS" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zyqzhangyanqiang@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Runtime复习整理"><span class="nav-number">1.</span> <span class="nav-text">Runtime复习整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime介绍"><span class="nav-number">1.1.</span> <span class="nav-text">Runtime介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">Runtime概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码到可执行文件过程"><span class="nav-number">1.1.2.</span> <span class="nav-text">代码到可执行文件过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码地址"><span class="nav-number">1.1.3.</span> <span class="nav-text">源码地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本和平台"><span class="nav-number">1.1.4.</span> <span class="nav-text">版本和平台</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-的交互"><span class="nav-number">1.2.</span> <span class="nav-text">Runtime 的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C-源代码"><span class="nav-number">1.2.1.</span> <span class="nav-text">Objective-C 源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSObject"><span class="nav-number">1.2.2.</span> <span class="nav-text">NSObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runtime-库"><span class="nav-number">1.2.3.</span> <span class="nav-text">Runtime 库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-常用术语的数据结构"><span class="nav-number">1.3.</span> <span class="nav-text">Runtime 常用术语的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类对象-objc-class"><span class="nav-number">1.3.1.</span> <span class="nav-text">类对象(objc_class)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-objc-object"><span class="nav-number">1.3.2.</span> <span class="nav-text">实例(objc_object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元类-Meta-Class"><span class="nav-number">1.3.3.</span> <span class="nav-text">元类(Meta Class)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ivar（objc-ivar）"><span class="nav-number">1.3.4.</span> <span class="nav-text">Ivar（objc_ivar）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method（objc-method）"><span class="nav-number">1.3.5.</span> <span class="nav-text">Method（objc_method）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEL-objc-selector"><span class="nav-number">1.3.6.</span> <span class="nav-text">SEL(objc_selector)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP"><span class="nav-number">1.3.7.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache（objc-cache）"><span class="nav-number">1.3.8.</span> <span class="nav-text">Cache（objc_cache）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property（objc-property-t）"><span class="nav-number">1.3.9.</span> <span class="nav-text">Property（objc_property_t）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Category-objc-category"><span class="nav-number">1.3.10.</span> <span class="nav-text">Category(objc_category)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-消息传递（dispatch-table）"><span class="nav-number">1.4.</span> <span class="nav-text">Runtime 消息传递（dispatch table）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递介绍"><span class="nav-number">1.4.1.</span> <span class="nav-text">消息传递介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递流程"><span class="nav-number">1.4.2.</span> <span class="nav-text">消息传递流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法中的隐藏参数"><span class="nav-number">1.4.3.</span> <span class="nav-text">方法中的隐藏参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime-消息转发（Message-Forwarding）"><span class="nav-number">1.5.</span> <span class="nav-text">Runtime 消息转发（Message Forwarding）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态方法解析-resolveInstanceMethod"><span class="nav-number">1.5.1.</span> <span class="nav-text">动态方法解析 - resolveInstanceMethod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定向-forwardingTargetForSelector"><span class="nav-number">1.5.2.</span> <span class="nav-text">重定向 - forwardingTargetForSelector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转发-forwardInvocation"><span class="nav-number">1.5.3.</span> <span class="nav-text">转发 - forwardInvocation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime应用"><span class="nav-number">1.6.</span> <span class="nav-text">Runtime应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历结构体中数据"><span class="nav-number">1.6.1.</span> <span class="nav-text">遍历结构体中数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取对应列表"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">获取对应列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSCoding的自动归档-解档"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">NSCoding的自动归档/解档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模型-字典互转-MJExtension"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">模型/字典互转(MJExtension)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态添加属性"><span class="nav-number">1.6.2.</span> <span class="nav-text">动态添加属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态添加方法与方法转发"><span class="nav-number">1.6.3.</span> <span class="nav-text">动态添加方法与方法转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#黑魔法-Method-Swizzling"><span class="nav-number">1.6.4.</span> <span class="nav-text">黑魔法(Method Swizzling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO实现"><span class="nav-number">1.6.5.</span> <span class="nav-text">KVO实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard-zhang-iOS</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
